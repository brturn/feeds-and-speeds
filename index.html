<html id="ALL">
<!--
    COPYRIGHT 2015-2016, Bryan Turner
    ALL RIGHTS RESERVED

    This software is distributed under the GPL v3.
    A copy of the GPL v3 may be found at http://www.gnu.org/licenses/gpl.html

    Bugs, Suggestions, and PayPal donations to: bryan.turner@pobox.com
-->

  <head>
    <title>Optimizing Feeds and Speeds Calculator for Milling</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <style type="text/css">
        body  {padding: 20px;}
        input {margin-bottom: 5px; padding: 2px 3px; width: 6em; float: right; }
        td    {padding: 4px;}

        div.container {
            width: 100%;
            margin: 0px;
            border: 1px solid gray;
            line-height: 150%;
        }

        div.header, div.footer {
            padding: 0.5em;
            background-color: #CCCCCC;
            clear: left;
        }

        h1.header {
            padding: 0;
            margin: 0;
        }

        div.left {
            float: left;
            width: 160px;
            margin: 0;
            padding: 1em;
        }

        div.content {
            border-left: 1px solid gray;
            padding: 1em;
        }

        ul {
            float: left;
            width: 100%;
            padding: 0;
            margin: 0;
            list-style-type: none;
        }

        li {
            display: inline;

            float: left;
            width: 16em;
            height: 1.6em;
            text-decoration: none;
            padding: 0.2em 0.6em;
            border-right: 1px solid #CCCCCC;
        }

        div.results li { width: 16em; }
        div.results ul li ul li { width: 6em; border: none;}
    </style>
  </head>

<body>
<div class="container">
    <div class="header">
        <!-- Donation button -->
        <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
            <h2 class="header" style="display: inline;">Milling Speeds &amp; Feeds</h2>
            <input type="hidden" name="cmd" value="_s-xclick"/>
            <input type="hidden" name="hosted_button_id" value="UXF9L3E8TEVJA"/>
            <input type="image" style="float: none;" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="Donate!"/>
        </form>

        <a href="instructions.html">Instructions</a>
   </div>

    <hr/>

    <div class="header"><b class="header">Machine</b></div>
    <ul>
        <li><input type="checkbox" id="in_METRIC" onclick="convertAll()">Metric?</li>
        <li>RPM             <small>(min, max)</small>   <input id="max_RPM" value="10350">              <input id="min_RPM" value="525">    </li>
        <li>RPM at Peak Torque                          <input id="in_PEAK_TORQUE_RPM" value="5020">                                        </li>
        <li>Feed            <small>(min, max)</small>   <input id="max_IPM" value="135">                <input id="min_IPM" value="1">      </li>
        <li>Spindle Power                               <input id="max_HP" value="1"></li>
    </ul>

    <div class="header"><b class="header">Tool</b></div>
    <ul>
        <li><select id="ux_E" onchange="uxPick('E')">
                <option value="HSS">High Speed Steel, 27-31</option>
                <option value="Carbide">Cemented Carbide, 75-91</option>
                <option value="CUSTOM">CUSTOM</option>
        </select></li>
        <li>Modulus of Elasticity               <input id="in_E" value="27"> <small>10^6 psi</small></li>
        <li>Diameter                            <input id="in_DIAMETER" value="0.375"></li>
        <li>#Teeth                              <input id="in_TEETH" value="3"></li>
        <li><input type="checkbox" id="in_BALLNOSE" onclick="inputChanged()">Ballnose?</li>
        <li>Stickout                            <input id="in_L" value="0.9"></li>
        <li>Helix Angle                         <input id="in_HELIX" value="30"></li>
    </ul>

    <div class="header"><b class="header">Material</b></div>
    <ul>
        <li>
            <select id="ux_UNITPOWER" onchange="uxPick('UNITPOWER')">
              <option value="Aluminum">Aluminum</option>
              <option value="Copper">Copper/Brass/Bronze</option>
              <option value="Iron">Iron</option>
              <option value="Steel">Steel</option>
              <option value="Stainless">Stainless Steel</option>
              <option value="Titanium">Titanium</option>
              <option value="Plastic">Plastic</option>
              <option value="Wood">Wood</option>
              <option value="CUSTOM">CUSTOM</option>
            </select>
        </li>
        <li>Unit Power                              <input id="in_UNITPOWER" value="0.33"></li>
        <li>SFM         <small>(min, max)</small>   <input id="max_SFM" value="600">            <input id="min_SFM" value="100"></li>
        <li>Chipload    <small>(min, max)</small>   <input id="max_CHIPLOAD" value="0.01">      <input id="min_CHIPLOAD" value="0.0008"></li>
    </ul>

    <div class="header"><b class="header">Cut</b></div>
    <ul>
        <li>DOC         <small>(min, max)</small>   <input id="max_DOC" value="0.75">           <input id="min_DOC" value="0.01"></li>
        <li>WOC         <small>(min, max)</small>   <input id="max_WOC" value="0.375">          <input id="min_WOC" value="0.01"></li>
        <li>Deflection  <small>(max)</small>        <input id="max_DEFLECTION" value="0.001"></li>
        <li>Reserve HP %                            <input id="in_RESERVE_HP"     value="5"></li>
        <li>Reserve Torque %                        <input id="in_RESERVE_TORQUE" value="5"></li>
        <li><input type="checkbox" id="in_ADAPTIVE" onclick="inputChanged()"><small>HSM / Adaptive / Constant TEA</small></li>
    </ul>

    <div class="header"><b class="header">RESULTS</b>
        <button onclick="new_compute()">Compute</button>
        <a id="CURRENT" href="">[Bookmark this link to save these parameters]</a>
    </div>
    <div id="OUT" class="results">
        <ul>
            <li><ul><li><b>RPM</b>   </li><li id="RPM"    style="font-weight: bold;"/></ul></li>
            <li><ul><li><b>Feed</b>  </li><li id="IPM"    style="font-weight: bold;"/></ul></li>
            <li><ul><li><b>Plunge</b></li><li id="PLUNGE" style="font-weight: bold;"/></ul></li>
        </ul>
        <ul>
            <li><ul><li>DOC </li><li id="DOC"/></ul></li>
            <li><ul><li>WOC </li><li id="WOC"/></ul></li>
            <li><ul><li>SFM </li><li id="SFM"/></ul></li>
        </ul>
        <div class="header"><b class="header">ADVANCED</b></div>
        <ul>
            <li><ul><li>MRR        </li><li id="MRR"/></ul></li>
            <li><ul><li>Cut Power  </li><li id="HP"/></ul></li>
            <li><ul><li>Deflection </li><li id="DEFLECTION"/></ul></li>
        </ul>
        <ul>
            <li><ul><li>Torque     <small>(in-lbs)</small> </li><li id="TORQUE"/></ul></li>
            <li><ul><li>Torque     <small>(oz-in)</small>  </li><li id="TORQUEOZ"/></ul></li>
            <li><ul><li>Force      <small>(lbs)</small>    </li><li id="P"/></ul></li>
        </ul>
        <ul>
            <li><ul><li>Chipload   </li><li id="CHIPLOAD"/></ul></li>
            <li><ul><li>Radial     </li><li id="RCTF"/></ul></li>
            <li><ul><li>Axial      </li><li id="ACTF"/></ul></li>
            <li><ul><li>Feed Adj.  </li><li id="FCF"/></ul></li>
        </ul>
        <ul>
            <li><ul><li>Adj. Unit Pwr </li><li id="UNITPOWER"/></ul></li>
            <li><ul><li>Eff. Diameter </li><li id="EFFECTIVE"/></ul></li>
            <li><ul><li>TEA  <small>(deg.)</small> </li><li id="TEA"/></ul></li>
        </ul>
    </div>

    <div class="header"><b class="header">Parameter Variations</b></div>
    <div id="ALTERNATIVES" class="content"></div>
    <div>
        <div id="chart_div" style="width: 900px; height: 500px;"></div>
        <div id="chart_div2" style="width: 900px; height: 500px;"></div>
    </div>

  <div class="footer">Copyright 2015-2016 by Bryan Turner, All Rights Reserved</div>
</div>    

<script type="text/javascript">

    var Modulus = {}
    Modulus.HSS = 27;
    Modulus.Carbide = 75;

    var cutParameters = {}
    // HSS cut parameters roughly taken from:
    //    Machinery's Handbook 29 (2012) pp1083-1084
    cutParameters.HSS = {};
    cutParameters.HSS.Aluminum  = [600, 160]    // SFM, then Chipload as (DIAMETER / XXX)]
    cutParameters.HSS.Copper    = [250, 160]    // ie:  [250, 160] ==> SFM = 250, Chipload = DIAMETER / 160
    cutParameters.HSS.Iron      = [80, 200]
    cutParameters.HSS.Steel     = [60, 250]
    cutParameters.HSS.Stainless = [70, 200]
    cutParameters.HSS.Titanium  = [70, 200]
    cutParameters.HSS.Plastic   = [500, 125]
    cutParameters.HSS.Wood      = [800, 100]

    // Carbide parameters roughly taken from:
    //    http://robbjack.com/technical/speed-and-feed
    cutParameters.Carbide = {};
    cutParameters.Carbide.Aluminum  = [2500, 80]
    cutParameters.Carbide.Copper    = [600, 80]
    cutParameters.Carbide.Iron      = [400, 100]
    cutParameters.Carbide.Steel     = [260, 300]
    cutParameters.Carbide.Stainless = [225, 200]
    cutParameters.Carbide.Titanium  = [230, 200]
    cutParameters.Carbide.Plastic   = [1300, 40]
    cutParameters.Carbide.Wood      = [1300, 80]

    // HSS cut parameters roughly taken from:
    //    Machinery's Handbook 29 (2012) pp1083-1084
    var unitPower = {};
    unitPower.Aluminum = 0.33
    unitPower.Copper = 0.80;
    unitPower.Iron = 0.85;
    unitPower.Steel = 1.00;
    unitPower.Stainless = 0.80;
    unitPower.Titanium = 0.80;
    unitPower.Plastic = 0.20;
    unitPower.Wood = 0.20;

    // ------------------------------------------------------------------------------
    // Milling Speeds & Feeds Calculator
    // by Bryan Turner, 2015-2016
    // All rights reserved.

    var OneHP = 33000;         // (lb-ft) per minute
    var InchesPerFoot = 12;
    var PI = Math.PI;

    // Metric Input Conversions (reverse for output)
    var SMMtoSFM     = 3.28083;     // SMM -> SFM
    var mmToInch     = 0.03937;     // mm -> Inch
    var KWToHP       = 1.34102;     // KW -> HP
    var KWcm3ToHPin3 = 21.9754;     // KW/cm^3 -> HP/in^3
    var NMtoFtLbs    = 0.73756;     // Nm -> Foot-Pounds
    var GPtoPSI6     = 0.14503;     // GigaPascals -> PSI*10^6
    var cm3ToIn3     = 0.06102;
    var KGtoLbs      = 2.20462;

    var useMetric    = false;
    var convertUnits = false;

    function new_compute()
    {
        parameters  = [];
        constants   = [];
        equations   = [];
        dynamic     = [];
        fns         = [];

        equations.parameter = [];   // A little hacky.  Don't like it.  Need equation -> parameter mapping.

        var METRIC      =        constant ('METRIC',  false,true,1);    useMetric = METRIC.v;       // Total hack..
        var BALLNOSE    =        constant ('BALLNOSE',false,true,1);
        var ADAPTIVE    =        constant ('ADAPTIVE',false,true,1);

        // ---------------------------------------------------------
        // Define the parameters & constants for the optimizer
        //                                 Name            Digits  Min     Max     Metric->Imperial
        var L           =        constant ('L',                 2,  0.01,   10,    mmToInch);
        var TEETH       =        constant ('TEETH',             0,  1,      99,    1);
        var UNITPOWER   =        constant ('UNITPOWER',         4,  0.01,   10,    1);              // HP / cu.in. -- No Metric for now
        var E           =        constant ('E',                 2,  0.01,   999,   1);              // Modulus of Elasticity (pounds per sq. inch -- No metric for now)
        var PEAK_TQ_RPM =        constant ('PEAK_TORQUE_RPM',   0,  1,      99999, 1);              // RPM at which we reach peak Torque
        var DIAMETER    =        constant ('DIAMETER',          4,  0.0001, 99,    mmToInch);
        var HELIX       =        constant ('HELIX',             0,  0,      90,    1);
        var RESERVE_HP  =        constant ('RESERVE_HP',        0,  0,      300,   1);
        var RESERVE_TORQUE=      constant ('RESERVE_TORQUE',    0,  0,      300,   1);

        // Order of parameters here defines the order of the 'finalize' pass:
        var RPM         =        parameter('RPM',               0,  1,      99999, 1);
        var AdjustedIPT =        parameter('AdjIPT',            4,  0.0001, 0.5,   mmToInch);       // Should setup with same values as chipload
        var IPM         =        parameter('IPM',               1,  0.1,    9999,  mmToInch);
        var MRR         =        parameter('MRR',               2,  0.01,   999,   cm3ToIn3);
        var HP          =        parameter('HP',                2,  0.01,   999,   KWToHP);
        var TORQUE      =        parameter('TORQUE',            2,  0.01,   9999,  NMtoFtLbs);
        var P           =        parameter('P',                 2,  0.01,   9999,  KGtoLbs);        // Tangential cutting force (lbs)
        var DEFLECTION  =        parameter('DEFLECTION',        5,  0,      0.01,  mmToInch);
        var SFM         =        parameter('SFM',               0,  1,      9999,  SMMtoSFM);
        var CHIPLOAD    =        parameter('CHIPLOAD',          4,  0.0001, 0.5,   mmToInch);       // Actual chipload
        var WOC         =        parameter('WOC',               3,  0.001,  99,    mmToInch);       // Width of Cut (radial engagement)
        var DOC         =        parameter('DOC',               3,  0.001,  99,    mmToInch);       // Depth of Cut (axial engagement)

        // Total hack..
        convertUnits = false;

        // --------------------------------
        // Scale some of the user values..
        RESERVE_HP.v     = 100 / (100 + RESERVE_HP.v );     // Derate HP
        RESERVE_TORQUE.v = 100 / (100 + RESERVE_TORQUE.v ); // Derate Torque
        E.v             *= 1000000;                         // Scale modulus of elasticity
        UNITPOWER.v     *= 1 - 0.01 * (HELIX.v - 14);       // Helix angle (1% per degree of positive lead after 14-degrees): Machinery's Handbook 29 (2012) pp1083-1084
        HP.max           = RESERVE_HP.v * HP.max;

        // --------------------------------------------------------------------------------
        // Apply various logical constraints (highlight errors for user)
        constraint( [DOC,L ],       function() { return DOC.max <= L.v });              // Can't cut deeper than stickout
        constraint( [WOC,DIAMETER], function() { return WOC.max <= DIAMETER.v });       // Can't cut wider than the endmill

        // --------------------------------------------------------------------------------
        // Constants derived from user inputs
        var ballnose         = BALLNOSE.v;
        var adaptive         = ADAPTIVE.v;
        var RADIUS           = DIAMETER.v/2;
        var MAX_TORQUE       = (HP.max * OneHP * InchesPerFoot) / (2 * Math.PI * PEAK_TQ_RPM.v);    // Max torque computed from derated HP

        // Moment of Inertia: This is the equation for a SOLID round beam, which is NOT equivelent to an endmill!
        // http://www.engineeringtoolbox.com/area-moment-inertia-d_1328.html
        var I                = (PI * Math.pow(DIAMETER.v,4)) / 64;        // Second moment of inertia (area) for solid round beam

        // --------------------------------------------------------------------------------
        // Values dynamically derived from the optimization parameters during search
        // - Most equations from:
        //   http://www.ingersoll-imc.com/products/ingersoll_cat-009_technical.pdf
        //
        var AvailableTorque          = derived( 'AVAIL',     NMtoFtLbs, [RPM],     function() { return Math.min(1,PEAK_TQ_RPM.v / RPM.v) * MAX_TORQUE });
        var EffectiveDiameter        = derived( 'EFFECTIVE', mmToInch,  [DOC],     function() { return (!ballnose || DOC.v >= RADIUS) ? DIAMETER.v : 2 * Math.sqrt( Math.pow(RADIUS,2) - Math.pow(RADIUS - DOC.v,2) ) });
        // Axial chip thinning: Use DOC & actual radius
        var AxialChipThinningFactor  = derived( 'ACTF',      1,         [DOC],     function() { return (!ballnose || DOC.v >= RADIUS) ? 1          : Math.min( 1, Math.sqrt(1-Math.pow(1-(DOC.v/RADIUS),2))) });
        // Radial chip thinning: Use WOC & effective diameter
        var RadialChipThinningFactor = derived( 'RCTF',      1,         [DOC,WOC], function() { return (!adaptive || WOC.v >= EffectiveDiameter.v/2) ? 1 : Math.min( 1, Math.sqrt(1-Math.pow(1-(2*WOC.v/EffectiveDiameter.v),2))) });
        var FeedCorrectionFactor     = derived( 'FCF',       1,         [DOC,WOC], function() { return AxialChipThinningFactor.v * RadialChipThinningFactor.v });

        // Equation from: http://zero-divide.net/?shell_id=151&article_id=4257
        var ToolEngagementAngle      = derived( 'TEA',       1,         [DOC,WOC], function() { return toDegrees( Math.acos( 1 - Math.min(WOC.v,DIAMETER.v) / RADIUS ) ) });

        // Rule-of-Thumb Plunge calculation.. TODO: design a better equation
        var PlungeIPM                = derived( 'PLUNGE',    mmToInch,  [IPM],     function() { return IPM.v / TEETH.v });

        // Display ounce-inch torque alongside the inch-pound torque
        // TODO: No Metric equivelent...
        var TorqueOz                 = derived( 'TORQUEOZ',  1,         [TORQUE],  function() { return TORQUE.v * 16 });

        // --------------------------------------------------------------------------------
        // TODO: More advanced torque curve: lookup table with linear approximation between entries
        dynamic_constraint( [RPM], function() { TORQUE.max = RESERVE_TORQUE.v * AvailableTorque.v });

        // --------------------------------------------------------------------------------
        // Equations to optimize
        // - Most equations from:
        //   http://www.ingersoll-imc.com/products/ingersoll_cat-009_technical.pdf
        //

        // -----------------------------------
        // The "classic" equations, in dependency order, assuming we have selected DOC, WOC, SFM, and CHIPLOAD:

        equation( RPM,         function() { return (SFM.v * InchesPerFoot) / (EffectiveDiameter.v * PI) } );
        equation( AdjustedIPT, function() { return CHIPLOAD.v / FeedCorrectionFactor.v } );
        equation( IPM,         function() { return (AdjustedIPT.v * TEETH.v * RPM.v) } );
        equation( MRR,         function() { return (IPM.v * WOC.v * DOC.v) } );
        equation( HP,          function() { return MRR.v * UNITPOWER.v } );
        equation( TORQUE,      function() { return (HP.v * OneHP * InchesPerFoot) / (2 * PI * RPM.v) } );
        equation( P,           function() { return (HP.v * OneHP) / SFM.v } );

        // "Cantilevered Beam Deflection with Point Load at end of Beam"  (http://www.engineersedge.com/beam_calc_menu.shtml)
        equation( DEFLECTION,  function() { return (P.v * Math.pow(L.v ,3)) / (3 * E.v * I) } );


        // -----------------------------------
        // Every other which-way to compute the above values via back-propagation
        //
        equation( SFM,         function() { return (RPM.v * EffectiveDiameter.v * PI) / InchesPerFoot } );
        equation( AdjustedIPT, function() { return IPM.v / (                TEETH.v * RPM.v) } );
        equation( RPM,         function() { return IPM.v / (AdjustedIPT.v * TEETH.v) } );
        equation( CHIPLOAD,    function() { return AdjustedIPT.v * FeedCorrectionFactor.v } );
        equation( IPM,         function() { return MRR.v / (        WOC.v * DOC.v) } );
        equation( WOC,         function() { return MRR.v / (IPM.v *         DOC.v) } );
        equation( DOC,         function() { return MRR.v / (IPM.v * WOC.v) } );
        equation( MRR,         function() { return HP.v  / UNITPOWER.v } );
        equation( RPM,         function() { return (HP.v * OneHP * InchesPerFoot) / (2 * PI * TORQUE.v) } );
        equation( HP,          function() { return (TORQUE.v * 2 * PI * RPM.v)  / (OneHP * InchesPerFoot) } );
        equation( SFM,         function() { return (HP.v * OneHP) / P.v } );
        equation( HP,          function() { return (P.v  * SFM.v) / OneHP } );
        equation( P,           function() { return (3 * E.v * I * DEFLECTION.v) / Math.pow(L.v ,3) } );

        // ---------------------------------------------------------------------
        // Run the optimizer a few times, looking for some valid feeds & speeds
        //
        for (var z = 0; z < 100; z++)
        {
            // Initialize a new point in the parameter space
            initialize(parameters);
            aneal();
            finalize();
            highlightRangeLimits(parameters);

            // If the resulting parameter space is valid, then record it.
            if ( validate(parameters) )
                domArray.push( [ MRR.v,
                                  0.99999 - DEFLECTION.v,
                                  AvailableTorque.v - TORQUE.v,
                                  RPM.v, WOC.v, DOC.v, IPM.v, HP.v, SFM.v, CHIPLOAD.v] );
        }

        if ( domArray.length > 1 )
        {
            // -----------------------------------------------------------------        
            // Pick a parameter set to display as the "result" - here we pick the one with maximum MRR
            //
            domArray.sort(function (a,b) {return b[0] - a[0];});    // Sort by MRR, descending
            domArray = domArray.splice(0,20)

            // Load this set of parameters
            SFM.v       = domArray[0][8]; update_derived(SFM);      update_dynamics(SFM);
            CHIPLOAD.v  = domArray[0][9]; update_derived(CHIPLOAD); update_dynamics(CHIPLOAD);
            DOC.v       = domArray[0][5]; update_derived(DOC);      update_dynamics(DOC);
            WOC.v       = domArray[0][4]; update_derived(WOC);      update_dynamics(WOC);

            // Recompute the parameters
            finalize();

            // Restore the loaded parameters (they were changed by finalization)
//            SFM.v       = domArray[0][8];
//            CHIPLOAD.v  = domArray[0][9];
//            DOC.v       = domArray[0][5];
//            WOC.v       = domArray[0][4];

            // --------------------------------------------
            //  Graphs

            // DOC/WOC axis, with MRR heat map, IPM-sized bubbles, labeled with RPM
            var graph = [];
            graph[0] = ['RPM', 'WOC', 'DOC', 'MRR', 'IPM'];
            for ( var i = 0; i < domArray.length; i++ )
                graph[graph.length] = [ ' ' + domArray[i][3], domArray[i][4], domArray[i][5], domArray[i][0], domArray[i][6] ];
            drawChart(graph, 'chart_div', docOptions);

            // RPM/IPM axis, with MRR heat map, and HP-sized bubbles
            graph = [];
            graph[0] = ['DOC','IPM', 'RPM', 'MRR', 'HP'];
            for ( var i = 0; i < domArray.length; i++ )
                graph[graph.length] = [ ' ' + domArray[i][5], domArray[i][6], domArray[i][3], domArray[i][0], domArray[i][7] ];
            drawChart(graph, 'chart_div2', rpmOptions);

            var alt = document.getElementById('ALTERNATIVES');
            alt.innerHTML = ""; // ' RPM  IPM  WOC  DOC  MRR <br/>';

            // --------------------------------
            // Undo scaling of the values so we can record the original inputs.
            //
            HP.max           = (HP.max / RESERVE_HP.v);
            RESERVE_HP.v     = (100 / RESERVE_HP.v) - 100;
            RESERVE_TORQUE.v = (100 / RESERVE_TORQUE.v) - 100;
            E.v             /= 1000000;
            UNITPOWER.v      = UNITPOWER.v / (1 - 0.01 * (HELIX.v - 14));

            // --------------------------------
            // Generate a URL with the inputs from the form so users can bookmark the parameters.
            //
            var inputs = document.getElementsByTagName('input');
            var params = "?";
            for (var index = 0; index < inputs.length; ++index)
            {
                var v = inputs[index];
                if ( v.id != "" && v.id != "in_METRIC") // Don't save the metric setting; everything else is imperial.
                {
                    if ( v.type == "checkbox" )
                        params += v.id + '=' + v.checked + '&'; 
                    else
                        params += v.id + '=' + v.value + '&';
                }
            }

            var selects = document.getElementsByTagName('select');
            for (var index = 0; index < selects.length; ++index)
            {
                var sel = selects[index];
                params += sel.id + '=' + sel.value + '&';
            }

            var cut = document.getElementById('CURRENT');
            cut.href = (window.location.href.split('?')[0]) + params;
        }

        // -----------------------------------------------------------------        
        // Display results - highlight if the results are invalid
        //
        displayAll();
        document.getElementById('OUT').style.backgroundColor = validate(parameters) ? "" : "pink";
    }

    // -----------------------------------------------------------------
    var parameters  = [];
    var constants   = [];
    var equations   = [];
    var dynamic     = [];
    var fns = [];
    var domArray  = [[0,0,0,0,0]];

    // Allocate an input parameter that remains constant
    function constant(name,decimals,min,max,metToImp)
    {
        var p     = {};
        p.name    = name;
        p.max     = getValue('in_'+name, metToImp);
        p.min     = p.max;
        p.v       = p.max;
        p.decimals= 5;
        p.metToImp= metToImp; // Metric to Imperial conversion
        constants.push(p);

        setupValue('in_'+name, min, max );  // this should go in a page-load function, not here
        return p;
    }
    
    // Allocate an input parameter with MIN/MAX range
    function parameter(name,decimals,min,max,metToImp)
    {
        var p       = {};
        p.name      = name;
        p.min       = getValue('min_'+name, metToImp);
        p.max       = getValue('max_'+name, metToImp);
        if ( p.min >= p.max ) highlightInputs(name,"pink");
        p.min       = Math.min( p.min, p.max );   // Force min <= max
        p.v         = p.max;
        p.decimals  = decimals;
        p.equations = [];
        p.derived   = [];
        p.dynamics  = [];
        p.metToImp  = metToImp; // Metric to Imperial conversion
        parameters.push(p);

//        if ( p.min == 0 ) p.min = 0.00001;
        if ( p.max == 0 ) p.max = 99999;

        // Setup HTML with event handlers, min/max/step, etc..  (TODO: this should go in a page-load function)
        setupValue('min_'+name, min, max );
        setupValue('max_'+name, min, max );
        return p;
    }

    // Add an equation to be computed during optimization
    function equation(p,eq)
    {
        fns[equations.length] = equations.length;   // HACKY; record indexes of equations in an array for shuffling.
        p.equations.push(eq);
        equations.push(eq);
        equations.parameter.push(p);  // Equation -> Parameter map.
    };

    // Add a derived value to be computed during optimization
    function derived(name,metToImp,vs,fn)
    {
        var p     = {};
        p.name    = name;
        p.max     = 999999;
        p.min     = 0;
        p.v       = 0;
        p.decimals= 5;
        p.equation= fn;
        p.metToImp= metToImp
        constants.push(p);
        for (var i = 0; i < vs.length; i++) // Register this derived constant so it is updated when these parameters change.
            vs[i].derived.push(p);
        return p;
    };

    // Add constraints to be checked during optimization
    function constraint(vs,e)    { if ( e() == false ) { for (var i = 0; i < vs.length; i++) highlightInputs(vs[i].name,"pink"); }};
    function dynamic_constraint(vs,e)  { for (var i = 0; i < vs.length; i++) vs[i].dynamics.push(e); };

    // Update all parameters using the equations
    function update()
    {
        for (var i = 0; i < fns.length; i++)
        {
            var p = equations.parameter[fns[i]];    // Which parameter?
            var v = equations[fns[i]]();            // Compute the update
            p.v = roundTo( Math.max( p.min, Math.min( v, p.max )), p.decimals );  // Round and pin the value
            if ( !isNumeric(p.v) ) p.v = p.min;     // Punt.  Maybe it'll recover.

            update_derived(p);
            update_dynamics(p);
        }
    }

    function finalize()
    {
        for (var i = 0; i < parameters.length; i++)
        {
            // For each parameter, execute the FIRST equation in it's list.
            var p = parameters[i];
            var v = p.equations[0]();
            p.v = roundTo( v, p.decimals );
            update_derived(p);
            update_dynamics(p);
        }
    }

    function aneal()
    {
        // Very Simple Optimizer...
        for (var r = 0; r < 20; r++)
        {
            shuffle(fns);   // Shuffle the equation indexes
            update();       // Execute the equations in random order
        }
    }

    function displayAll()
    {
        // Update the display
        display(parameters);
        display(constants);
    }

    // -----------------------------------------------------------------
    // Utility functions

    function rng()
    {
        // Could be replaced with deterministic function to always generate the 'same' cuts for the same input parameters.
        // For now, leaving it as random.
        return Math.random();
    }

    function avg( minC, maxC )
    {
        var delta = maxC - minC;
        return minC + (rng() * delta);
    }

    // Is this parameter valid?
    function validP(p)
    {
        return  p.v   <= p.max &&
                p.v   >= p.min;
    }
    
    function highlight(name,color)
    {
        var v = document.getElementById(name);
        if ( v != null )
            v.style.backgroundColor = color;
    }

    function highlightInputs(name,color)
    {
        highlight('min_'+name,color);
        highlight('max_'+name,color);
        highlight('in_'+name,color);
    }

    function outputConversion(val,scale)
    {
        if ( useMetric ) return roundTo( val / scale, 4 );
        return val;
    }

    // Get a parameter value from the input form, validate & highlight errors
    function getValue(n,scale)
    {
        var v = document.getElementById(n);
        if ( v == null )  return 0;

        if ( v.type == "checkbox" )
            return v.checked;

        var x = eval(v.value); //parseFloat(v.value);
//        if ( !isNumeric(x) ) x = eval(v.value);
        highlight( n, isNumeric(x) ? "" : "yellow");        // Highlight non-number inputs
//        console.info(n,v.value,'=',x);

        // Case 1: no Metric, no Conversion     -- Inputs are Imperial, don't convert them
        // Case 2: no Metric, with Conversion   -- Inputs are Metric,   convert to Imperial
        // Case 3: Metric,    no Conversion     -- Inputs are Metric,   don't convert them
        // Case 4: Metric,    with Conversion   -- Inputs are Imperial, convert to Metric

        if ( !useMetric && !convertUnits ) { in_scale = 1;     out_scale = 1; }
        if ( !useMetric &&  convertUnits ) { in_scale = scale; out_scale = 1; }

        if (  useMetric && !convertUnits ) { in_scale = scale; out_scale = 1; }
        if (  useMetric &&  convertUnits ) { in_scale = 1;     out_scale = 1/scale; }

        ret = Math.max( 0, x * in_scale);                   // Don't allow negatives
        if ( convertUnits )
            v.value = roundTo( ret * out_scale, 4 );        // Convert values in place
        return ret;
    }

    // Setup HTML events, min/max/step, etc.
    function setupValue(n,min,max,step)
    {
        var v = document.getElementById(n);
        if ( v == null )  return;
        if ( v.type == "checkbox" )  return;

        v.setAttribute("onchange", "inputChanged('"+n+"')" ); // Pass the ID into the change function
//        v.setAttribute("min", min);
//        v.setAttribute("max", max);
//        v.setAttribute("step", (min == 0) ? 0.0001 : min);
//        v.setAttribute("type", "number");
    }

    function update_derived(p)
    {
        // Update derived values
        for (var j = 0; j < p.derived.length; j++)
        {
            var d = p.derived[j];
            d.v = roundTo( d.equation(), p.decimals );
        }
    }

    function update_dynamics(p)
    {
        // Update dynamic equations
        for (var j = 0; j < p.dynamics.length; j++)
            p.dynamics[j]();
    }

    // Initialize the variables to random values near the middle of their ranges
    function initialize(vs)
    {
        for (var i = 0; i < vs.length; i++)
            vs[i].v = roundTo( avg( vs[i].min, vs[i].max ), vs[i].decimals );

        for (var i = 0; i < vs.length; i++)
            vs[i].derived
    }

    // Check that the result values are within their MIN/MAX range
    function validate(vs)
    {
        var valid = true;
        for (var i = 0; i < vs.length; i++)
            valid = valid && validP( vs[i] );
        return valid;
    }

    function convertAll()
    {
        convertUnits = true;
        inputChanged(null);
    }

    // Update the display with the values of the variables
    function display(vs)
    {
        for (var i = 0; i < vs.length; i++)
        {
            var item = document.getElementById(vs[i].name);
            
            if ( item != null )
            {
                item.innerHTML = outputConversion( vs[i].v, vs[i].metToImp );

                // Highlight values near their limits..
                var close_to_limit = Math.abs(vs[i].v - vs[i].max) <  (vs[i].max * 0.05);
                var beyond_limit = vs[i].v < vs[i].min ||
                                   vs[i].v > vs[i].max ||
                                   !isNumeric(vs[i].v);

                if ( beyond_limit )         item.style.backgroundColor = "red";
                else if ( close_to_limit )  item.style.backgroundColor = "orange";
                else item.style.backgroundColor = "";
            }
//            else
//                console.info( 'Missing: ', vs[i].name );
        }
    }

    function highlightRangeLimits( vs )
    {
        for (var i = 0; i < vs.length; i++)
        {
            var min = document.getElementById('min_'+vs[i].name);
            var max = document.getElementById('max_'+vs[i].name);
                
            if ( min != null && vs[i].v < vs[i].min ) (min.style.backgroundColor == "") ? min.style.backgroundColor = "cyan" : null;
            if ( max != null && vs[i].v > vs[i].max ) (max.style.backgroundColor == "") ? max.style.backgroundColor = "cyan" : null;
        }
    }

    function uxDisable(name)
    {
        var v = document.getElementById(name);
        v.style.backgroundColor = "LightGray";
        v.disabled = true;
    }

    function uxEnable(name)
    {
        var v = document.getElementById(name);
        v.style.backgroundColor = "";
        v.disabled = false;
    }

    function uxPick(name)
    {
        inputChanged();
    }

    function reset_compute()
    {
        domArray  = [];
        drawChart([['RPM', 'WOC', 'DOC', 'MRR', 'IPM'],['0',0,0,0,0]], 'chart_div', docOptions);
        drawChart([[' ','IPM', 'RPM', 'MRR', 'HP'],['',0,0,0,0]], 'chart_div2', rpmOptions);
        document.getElementById('ALTERNATIVES').innerHTML = "";
    }

    function inputChanged(v)
    {
        var eTool = document.getElementById("ux_E");
        var vTool = eTool.options[eTool.selectedIndex].value;

        var eMat = document.getElementById("ux_UNITPOWER");
        var vMat = eMat.options[eMat.selectedIndex].value;

        // Some fields are locked when using the pulldowns..
        uxEnable("in_UNITPOWER");
        uxEnable("in_E");
        uxEnable("max_SFM");
        uxEnable("max_CHIPLOAD");

        if ( vTool != "CUSTOM" ) { uxDisable("in_E");         document.getElementById('in_E').value         = Modulus[vTool];  }
        if ( vMat  != "CUSTOM" ) { uxDisable("in_UNITPOWER"); document.getElementById('in_UNITPOWER').value = unitPower[vMat]; }

//*
        if ( vTool != "CUSTOM" && vMat != "CUSTOM" )
        {
            // Load SFM & Chipload from the table.
            document.getElementById('max_SFM').value = cutParameters[vTool][vMat][0];
            document.getElementById('max_CHIPLOAD').value = roundTo( eval(document.getElementById('in_DIAMETER').value) / cutParameters[vTool][vMat][1], 4);
            uxDisable("max_SFM");
            uxDisable("max_CHIPLOAD");
        }
//*/
        reset_compute();
        new_compute();
    }

    // -----------------------------------------------------------------------------------------
    // Code imported from other sources
    
    // http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
    // The de-facto unbiased shuffle algorithm is the Fisher-Yates (aka Knuth) Shuffle.
    // See https://github.com/coolaj86/knuth-shuffle
    function shuffle(array) {
      var currentIndex = array.length, temporaryValue, randomIndex ;

      // While there remain elements to shuffle...
      while (0 !== currentIndex) {

        // Pick a AVAILABLE element...
        randomIndex = Math.floor(rng() * currentIndex);
        currentIndex -= 1;

        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }

      return array;
    }

    // http://www.jacklmoore.com/notes/rounding-in-javascript/
    function roundTo(value, decimals) {
        return Number(Math.round(value+'e'+decimals)+'e-'+decimals);
    }

    // http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    // Somewhere on StackOverflow...
    function toDegrees (angle) {
      return angle * (180 / Math.PI);
    }

    function toRadians (angle) {
      return angle * (Math.PI / 180);
    }

    // ---------------------------------------------------------------------------------------
    // Google Charts
    //

    var docOptions = {
        colorAxis: {colors: ['white', 'red']},

        title: 'RPM label, MRR heatmap, IPM size',
        hAxis: {title: 'Width of Cut'},
        vAxis: {title: 'Depth of Cut'},
    };

    var rpmOptions = {
        colorAxis: {colors: ['white', 'red']},

        title: 'DOC label, MRR heatmap, HP size',
        hAxis: {title: 'Inches per Minute'},
        vAxis: {title: 'Spindle RPM'},
    };


    function drawChart(doms,id,options)
    {
        if ( typeof google != "undefined" )
        {
            var data = google.visualization.arrayToDataTable(doms);
            var chart = new google.visualization.BubbleChart(document.getElementById(id));
            chart.draw(data, options);
        }
    }

    </script>

    <script type="text/javascript" src="https://www.google.com/jsapi"></script>
    <script type="text/javascript">google.load('visualization', '1', {packages: ['corechart']});</script>

    <script type="text/javascript">
        // --------------------------------
        // Decode the URL parameters - fill in the text boxes on the page for any parameter sent in the query string.
        //
        var query = window.location.search.substring(1);
        var vars = query.split("&");
        for (var i=0;i<vars.length;i++)
        {
            var pair = vars[i].split("=");
            if ( pair[0] != null && pair[0] != "")
            {
                var v = document.getElementById( pair[0] );
                if ( v != null )
                    if ( v.type == "checkbox" )
                        v.checked = pair[1] == 'true'; 
                    else
                        v.value = pair[1];
            }
        }

        // ---------------------------------------------------------------------------------------
        // Run new_compute to get things rolling
        new_compute();

    </script>


    </body>
 </html>
 
 
